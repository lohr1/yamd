
#include "lj_direct_summation.h"
#include "verlet.h"
#include "xyz.h"
#include "helpers.h"
#include "berendsen.h"
//#include "gnuplot-iostream.h"

#include <fstream>
#include <iostream>

int main(int argc, char *argv[]) {
    // Takes lattice (generated by a python script), sets random velocities, and
    // uses Berendsen thermostat to equilibrate the system
    auto[names, positions]{read_xyz("/home/robin/School/yamd/milestones/05/lattice.xyz")};

    Atoms atoms{positions};
    atoms.velocities.setRandom();

    // Integrate
    double mass = 1.0;
    double epsilon = 1.0;
    double sigma = 1.0;

    double expr = sqrt(mass * sigma * sigma / epsilon);
    double time_tot = 10 * expr;
    double time_step = 0.001 * expr;
    double relax_const = time_step*1000;
    int nb_steps = time_tot / time_step;
    int N = atoms.nb_atoms();

    // Calc forces, store in atoms. Also calc energies.
    double PE = lj_direct_summation(atoms, epsilon, sigma);
    double KE = kinetic_energy(atoms);
    double T = temp(KE, N);

    // To monitor Energies (First index = potential) (Third index = temp)
    Eigen::Array3Xd Energies(3, nb_steps);


    // Variables for XYZ output
    double out_thresh = expr;
    std::string dir = "/home/robin/School/yamd/cmake-build-release/milestones/05/";
    std::ofstream traj(dir + "lattice_traj.xyz");
    // First frame
    write_xyz(traj, atoms);

    for (int i = 0; i < nb_steps; ++i) {
        // Monitor Energies
        Energies(0, i) = PE;
        Energies(1, i) = KE;
        Energies(2, i) = T;

        // Verlet predictor step (changes pos and vel)
        verlet_step1(atoms, time_step);

        // Update forces with new positions
        PE = lj_direct_summation(atoms, epsilon, sigma);

        // Verlet step 2 updates velocities, assuming the new forces are present:
        verlet_step2(atoms, time_step);

        // Berendsen velocity rescaling
        berendsen_thermostat(atoms, 300, time_step, relax_const);

        // Calc new KE
        KE = kinetic_energy(atoms);
        T = temp(KE, N);

        // XYZ output
        if(i > out_thresh) {
            write_xyz(traj, atoms);
            out_thresh += expr;
        }
    }

    traj.close();

    // Save potential energy to a file
    std::ofstream potential_file(dir + "potential_energy.txt");
    if (potential_file.is_open()) {
        for (int i = 0; i < nb_steps; ++i) {
            potential_file << i << " " << Energies(0, i) << "\n";
        }
        potential_file.close();
    } else {
        std::cerr << "Unable to open potential_energy.txt";
        return 1;
    }

    // Save kinetic energy to a file
    std::ofstream kinetic_file(dir + "kinetic_energy.txt");
    if (kinetic_file.is_open()) {
        for (int i = 0; i < nb_steps; ++i) {
            kinetic_file << i << " " << Energies(1, i) << "\n";
        }
        kinetic_file.close();
    } else {
        std::cerr << "Unable to open kinetic_energy.txt";
        return 1;
    }

    // Save potential energy to a file
    std::ofstream temperature_file(dir + "temperature.txt");
    if (temperature_file.is_open()) {
        for (int i = 0; i < nb_steps; ++i) {
            temperature_file << i << " " << Energies(2, i) << "\n";
        }
        temperature_file.close();
    } else {
        std::cerr << "Unable to open temperature.txt";
        return 1;
    }

    return 0;
}
