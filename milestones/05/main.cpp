
#include "lj_direct_summation.h"
#include "verlet.h"
#include "xyz.h"
#include "helpers.h"
#include "berendsen.h"
//#include "gnuplot-iostream.h"

#include <fstream>
#include <iostream>

int main(int argc, char *argv[]) {
    // Takes lattice (generated by a python script), sets random velocities, and
    // uses Berendsen thermostat to equilibrate the system
    std::string xyz_file = "/home/robin/School/yamd/xyzs/lattice.xyz";
    auto[names, positions]{read_xyz(xyz_file)};

    Atoms atoms{positions};
    atoms.velocities.setRandom();

    // Integrate
    double mass = 1.0;
    double epsilon = 1.0;
    double sigma = 1.0;

    double expr = sqrt(mass * sigma * sigma / epsilon);
    double time_tot = 40 * expr;
    double time_step = 0.001 * expr;
    double relax_const = 1 * expr;
    int nb_steps = time_tot / time_step;
    int N = atoms.nb_atoms();

    // Calc forces, store in atoms. Also calc energies.
    double PE = lj_direct_summation(atoms, epsilon, sigma);
    double KE = kinetic_energy(atoms);
    double T = temp(KE, N);

    // To monitor values (potential, kinetic, temp)
    Eigen::Array3Xd Energies(3, nb_steps+1);


    // Variables for XYZ output
    double iter_out = expr / time_step; // Output position every iter_out iterations
    double out_thresh = iter_out; // Threshold to keep track

    // Trajectory file:
    std::string dir = "/home/robin/School/yamd/cmake-build-release/milestones/05/";
    std::ofstream traj(dir + "trajectory.xyz");
    // First frame
    write_xyz(traj, atoms);

    for (int i = 0; i < nb_steps; ++i) {
        // Monitor Energies
        Energies(0, i) = PE;
        Energies(1, i) = KE;
        Energies(2, i) = T;

        // Verlet predictor step (changes pos and vel)
        verlet_step1(atoms, time_step);

        // Update forces with new positions
        PE = lj_direct_summation(atoms, epsilon, sigma);

        // Verlet step 2 updates velocities, assuming the new forces are present:
        verlet_step2(atoms, time_step);

        // Berendsen velocity rescaling
        berendsen_thermostat(atoms, 300, time_step, relax_const);

        // Calc new KE
        KE = kinetic_energy(atoms);
        T = temp(KE, N);

        // XYZ output
        if(i > out_thresh) {
            write_xyz(traj, atoms);
            out_thresh += iter_out;
        }
    }

    // Save finals
    Energies(0, nb_steps) = PE;
    Energies(1, nb_steps) = KE;
    Energies(2, nb_steps) = T;

    traj.close();

    // Save all energies to a CSV file
    std::ofstream energies_file(dir + "data.csv");
    if (energies_file.is_open()) {
        energies_file << "Time, Potential Energy, Kinetic Energy, Temperature\n";
        for (int i = 0; i < nb_steps + 1; ++i) {
            energies_file << i * time_step << ", " << Energies(0, i) << ", " << Energies(1, i) << ", " << Energies(2, i) << "\n";
        }
        energies_file.close();
    } else {
        std::cerr << "Unable to open data.csv";
        return 1;
    }

    return 0;
}
